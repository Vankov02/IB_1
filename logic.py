import bitarray
import random
from sympy import nextprime


def gcd(a, b):
    # Функция для вычисления наибольшего общего делителя двух чисел
    while b:
        # Пока b не станет равным 0, выполняется цикл
        a, b = b, a % b
        # На каждой итерации происходит замена a на b, а b на остаток от деления a на b
    return a
    # Возвращается наибольший общий делитель


def gen_right_prime_number(start, end):
    # Функция для генерации простого числа из заданного диапазона
    x = nextprime(random.randint(0xfffffff, 0xffffffffffffff))
    # Генерируется случайное простое число из диапазона
    while x % 4 != 3:
        # Пока число не будет иметь форму 4k + 3, где k - целое число, генерируется новое число
        x = nextprime(random.randint(0xfffffff, 0xffffffffffffff))
    return x
    # Возвращается простое число, удовлетворяющее условиям


def create_rand_key(m):
    # Функция для создания случайного ключа
    # 1 step
    q = gen_right_prime_number(0xfffffff, 0xffffffffffffff)
    # Генерация правильного простого числа q ( 0xfffffff представляет собой число в шестнадцатеричной системе счисления,
    # которое равно десятичному числу 268435455.
    # 0xffffffffffffff представляет собой число в шестнадцатеричной системе счисления, которое равно десятичному числу
    # 281474976710655.)
    p = gen_right_prime_number(0xffffffff, 0xffffffffffffff)
    # Генерация правильного простого числа p
    N = p * q
    # Вычисление произведения простых чисел
    # 2 step
    s = N
    # Инициализация переменной s значением N
    while gcd(N, s) > 1:
        # Пока НОД(N, s) больше 1, генерируется случайное значение s
        s = random.randint(1, N)
    u = [(s * s) % N]
    # Вычисление первого элемента последовательности u
    # step 3
    x = []
    # Создание пустого списка x
    for i in range(0, m):
        # Цикл по количеству элементов в ключе
        u.append(u[i]**2 % N)
        # Вычисление следующего элемента последовательности u
        x.append(u[i+1] & 0b1)
        # Получение каждого второго элемента последовательности u и добавление его в список x
    # step 4
    while len(x) % 8 > 0:
        # Пока длина списка x не будет кратна 8, выполняется цикл
        x = [0].append(x)
        # Добавляется недостающее количество нулей до кратности 8
    result = []
    # Создается пустой список result
    for i in range(0, len(x), 8):
        # Цикл по списку x с шагом 8
        k = 0
        # Инициализация переменной k
        for j in range(0, 8):
            # Цикл по 8 элементам
            k += x[i+j] * (7 - j)**2
            # Подсчет значения k согласно формуле
        result.append(k)
        # Добавление значения k в список result
    return x
    # Возвращается случайно сгенерированный ключ


# преобразование текстового сообщения в битовую строку.
def str2bits(message):
    # Функция для преобразования текстового сообщения в битовую строку
    bit_str = message.encode('utf-8')
    # Преобразование текстового сообщения в байтовую строку с кодировкой UTF-8
    print('encode: ', bit_str)
    # Вывод на печать закодированной строки для отладки
    result = bitarray.bitarray()
    # Создание пустой битовой строки для хранения результата
    temp = []
    # Создание временного списка для хранения битовых значений
    for i in bit_str:
        # Цикл по байтам закодированной строки
        order = 0x80
        # Инициализация переменной order для создания маски
        for j in range(0, 8):
            # Цикл по битам в байте
            temp.append(i & order > 0)
            # Добавление бита в список temp, если бит в исходном байте установлен в 1
            order = order >> 1
            # Сдвиг маски на один бит вправо для проверки следующего бита
    result += [i for i in temp]
    # Добавление битов из списка temp в битовую строку result
    print('bit string: ', result)
    # Вывод на печать битовой строки для отладки
    return result
    # Возврат битовой строки


# преобразование битовой строки в строку символов (байтовую строку)
def bits2str(bit_str):
    # Создаем пустую строку для хранения результирующего сообщения
    res_string = b''
    # Итерируемся по битовой строке с шагом 8, чтобы извлечь байты
    for i in range(0, len(bit_str), 8):
        # Инициализируем переменную для хранения текущего символа
        symbol = 0
        # Итерируемся по 8 битам в байте
        for j in range(0, 8):
            # Вычисляем значение символа, применяя операции побитового сдвига и сложения
            symbol += bit_str[i + j] * 2 ** (7 - j)
        # Преобразуем целое число в байт и добавляем его к результирующей строке
        res_string += symbol.to_bytes(1, byteorder='little', signed=False)
    # Возвращаем расшифрованное текстовое сообщение
    return res_string


def xor_bits_str(Fstr, Sstr):
    # Функция для выполнения операции XOR над двумя битовыми строками
    result = bitarray.bitarray()
    # Создание пустой битовой строки для хранения результата
    temp = []
    # Создание временного списка для хранения битовых значений
    for i in range(0, len(Fstr)):
        # Цикл по битам в битовых строках
        temp.append((int(Fstr[i]) + int(Sstr[i])) % 2)
        # Вычисление результата операции XOR над соответствующими битами и добавление во временный список
    result += [i for i in temp]
    # Добавление битов из списка temp в битовую строку result
    return result
    # Возврат битовой строки с результатом операции XOR


def xor_bit_str(str):
    # Функция для выполнения операции XOR над битовой строкой
    result = False
    # Инициализация переменной результата
    for i in range(0, len(str)):
        # Цикл по битам в битовой строке
        result = (result or str[i]) and not (result and str[i])
        # Вычисление результата операции XOR между текущим значением результата и текущим битом
    return int(result)
    # Возврат результата операции XOR


def add_bits_str(Fstr, Sstr):
    # Функция для выполнения операции сложения по модулю 2 над двумя битовыми строками
    result = bitarray.bitarray()
    # Создание пустой битовой строки для хранения результата
    temp = []
    # Создание временного списка для хранения битовых значений
    for i in range(0, len(Fstr)):
        # Цикл по битам в битовых строках
        temp.append(int(Fstr[i]) == 1 and int(Sstr[i]) == 1)
        # Вычисление результата операции сложения по модулю 2 и добавление во временный список
    result += [i for i in temp]
    # Добавление битов из списка temp в битовую строку result
    # print('+++++++++++++++++++++++++++++++++++++++')
    # print(Fstr)
    # print(Sstr)
    # print(result)
    # print('+++++++++++++++++++++++++++++++++++++++')
    return result
    # Возврат битовой строки с результатом операции сложения по модулю 2


def gamming_message(message):
    # Функция для шифрования сообщения с использованием гаммирования
    m = len(message)
    # Получение длины сообщения
    key = bitarray.bitarray()
    # Создание пустой битовой строки для хранения ключа
    rand_key = create_rand_key(m * 8)
    # Генерация случайного ключа заданной длины
    key += [i for i in rand_key]
    # Добавление сгенерированного ключа к основному ключу
    print(message)
    # Вывод на печать исходного сообщения
    bit_message = str2bits(message)
    # Преобразование сообщения в битовую строку
    chiper_message = xor_bits_str(bit_message, key)
    # Шифрование сообщения с использованием ключа
    print(bit_message)
    # Вывод на печать битовой строки сообщения для отладки
    print(key)
    # Вывод на печать ключа для отладки
    print(chiper_message)
    # Вывод на печать зашифрованного сообщения для отладки
    return chiper_message, rand_key
    # Возврат зашифрованного сообщения и ключа


def hi_kvadrat_test(Str):
    # Функция для проверки равномерности последовательности с использованием хи-квадрат теста
    Zeros = Str.count(0)
    # Подсчет количества нулей в последовательности
    Units = Str.count(1)
    # Подсчет количества единиц в последовательности
    N = len(Str)
    # Получение общей длины последовательности
    S = N * ((Zeros / N - 0.5) * (Zeros / N - 0.5) / 0.5
             + (Units / N - 0.5) * (Units / N - 0.5) / 0.5)
    # Вычисление значения статистики хи-квадрат
    if S > 5.991:
        # Проверка условия для отвержения гипотезы
        print('Гипотеза о равномерности последовательности отвергается')
        # Вывод на печать результата теста
    else:
        print('Гипотеза о равномерности последовательности не отвергается')
        # Вывод на печать результата теста
    print(S)
    # Вывод на печать значения статистики хи-квадрат
    return S > 5.991
    # Возврат результата теста


def scrambler(polinom, startstr, message):
    # Инициализация пустого массива для хранения ключа и пустого списка scramStr
    result_key = bitarray.bitarray()
    scramStr = []

    # Проходим по всем символам в строке startstr
    for i in range(0, len(startstr) - 1):
        # Преобразуем каждый символ строки startstr в целое число и добавляем его в массив scramStr
        scramStr.append(int(startstr[i]))
    # Выводим на печать массив scramStr для отладки
    print("scramStr = ", scramStr)

    # Инициализация временного массива temp для хранения временных результатов
    temp = []

    # Генерация ключа для скремблирования
    for i in range(0, 8 * len(message)):
        # Получаем следующий бит, используя XOR над текущим состоянием скремблера и полиномом
        nextbit = xor_bit_str(add_bits_str(scramStr, polinom))
        # Добавляем последний бит текущего состояния скремблера в массив temp
        # temp.append(scramStr[7])
        temp.append(scramStr[6])

        # Сдвигаем состояние скремблера вправо на один бит
        # ((7, 0, -1))
        for j in range(6, -1, -1):
            scramStr[j] = scramStr[j - 1]
        # Устанавливаем первый бит скремблера в новое значение nextbit
        scramStr[0] = nextbit

    # Проверяем последовательность на равномерность с помощью хи-квадрат теста
    hi_kvadrat_test(temp)

    # Добавляем временные результаты в ключ
    result_key += [i for i in temp]

    # Преобразуем сообщение в битовую строку
    bit_message = str2bits(message)
    # Выводим на печать битовую строку сообщения для отладки
    print('bit message: ', bit_message)

    # Шифруем сообщение с использованием ключа
    chiper_message = xor_bits_str(bit_message, result_key)

    # Возвращаем зашифрованное сообщение и ключ
    return chiper_message, result_key


def decipher(cipher_bit_text, key):
    # Функция для расшифрования зашифрованного сообщения
    dechiper_message = xor_bits_str(cipher_bit_text, key)
    # Расшифрование сообщения с использованием ключа
    print('dec message: ', dechiper_message)
    # Вывод на печать расшифрованного сообщения для отладки
    resString = bits2str(dechiper_message)
    # Преобразование битовой строки в строку символов
    print(resString.decode('utf-8'))
    # Вывод расшифрованного сообщения на печать
    return resString.decode('utf-8')
    # Возврат расшифрованного сообщения


def find_period():
    # Функция для поиска периода скремблера
    input = open('polinom.txt', 'r')
    polinom = input.read()
    input.close()
    # Чтение полинома из файла
    input = open('startVector.txt', 'r')
    startVector = input.read()
    input.close()
    # Чтение начального вектора из файла

    scramStr = []
    for i in range(0, len(startVector) - 1):
        scramStr.append(int(startVector[i]))
    # Инициализация начального состояния скремблера
    temp = []
    i = 0

    while True:
        if scramStr in temp:
            print('Find period of scrambler = ', len(temp) - temp.index(scramStr))
            break
        # Проверка наличия периода в списке временных результатов
        iterStr = []
        for item in scramStr:
            iterStr.append(item)
        temp.append(iterStr)
        # Добавление текущего состояния скремблера в список временных результатов
        nextbit = xor_bit_str(add_bits_str(scramStr, polinom))
        # Вычисление следующего бита
        lastNum = scramStr[7]
        for j in range(7, 0, -1):
            scramStr[j] = scramStr[j - 1]
        scramStr[0] = nextbit
        i += 1
        # Обновление состояния скремблера и увеличение счетчика итераций


def move_bit_left(bitStr):
    # Функция для сдвига битовой строки влево на один бит
    return bitStr[1:] + bitStr[:1]
    # Возвращение результата сдвига


def correlation():
    # Открытие файла для чтения ключа
    input = open('keyScram.txt', 'r')
    key = input.read()
    input.close()
    # Чтение ключа из файла и закрытие файла

    # Сдвиг ключа влево и вычисление его корреляции с самим собой
    newKey = move_bit_left(key)
    newKey = xor_bits_str(key, newKey)
    e = 0
    n = 0
    for i in range(0, len(key)):
        # Подсчет количества совпадающих битов (e) и различных битов (n)
        if int(key[i]) == int(newKey[i]):
            e += 1
        else:
            n += 1
    # Вывод результатов корреляции
    print('e =', e, 'n =', n, 'size = ', len(key))
    # Вычисление и вывод результата корреляции
    print('result = ', abs((e - n) / len(key)))
    if abs((e - n) / len(key)) < 0.05:
        # Проверка гипотезы о корреляции
        print("Гипотеза о корреляции не отвергается")
    else:
        print("Гипотеза о корреляции отвергается")


def balance():
    # Открытие файла для чтения ключа
    input = open('keyScram.txt', 'r')
    key = input.read()
    input.close()
    # Чтение ключа из файла и закрытие файла
    # количество единиц и нулей
    e = 0
    n = 0

    for i in range(0, len(key)):
        # Подсчет количества единиц и нулей в ключе
        if int(key[i]) == 1:
            e += 1
        else:
            n += 1

    # Вывод результатов баланса
    print('e =', e, 'n =', n, 'size = ', len(key))
    # Проверка сбалансированности последовательности
    print('result = ', abs(e - n))
    if abs(e - n) <= 1:
        print("Последовательность сбалансирована")
    else:
        print("Последовательность не сбалансирована")


#  анализируем содержимое файла "keyScram.txt", который предполагается содержащим бинарную последовательность.
#  Разбиваем эту последовательность на циклы и проверяем, соответствует ли она определенному критерию цикличности.
#  Если последовательность циклична, она выводим соответствующее сообщение.
def cyclicity():
    # Открываем файл для чтения ключа
    input = open('keyScram.txt', 'r')
    key = input.read()
    input.close()
    # Считываем содержимое файла в переменную key и закрываем файл

    tmp = []
    cycle = []
    tmp.append(key[0])
    # Создаем список для временного хранения циклов и пустой список для хранения циклов
    # Добавляем первый элемент последовательности во временный список
    for i in range(1, len(key)):
        if key[i - 1] != key[i]:
            cycle.append(tmp)
            tmp = [key[i]]
        else:
            tmp.append(key[i])
    # Разбиваем последовательность на циклы и добавляем их в список циклов

    lens = []
    for i in range(0, len(cycle)):
        lens.append(len(cycle[i]))
    # Создаем список для хранения длин циклов
    lens.sort()
    # Сортируем длины циклов по возрастанию

    count = {}
    for i in range(0, len(lens)):
        count[i + 1] = lens.count(lens[i])
    # Создаем словарь, в котором ключи - это длины циклов, а значения - количество циклов каждой длины

    for i in count.keys():
        # Проверяем каждую длину цикла
        if abs(count[i] / len(cycle)) > pow(1/2, i):
            # Проверяем условие наличия цикличности по формуле
            print("Последовательность не циклична")
            return
    print("Последовательность циклична")
    # Если условие цикличности не нарушено, считаем последовательность цикличной


def f(x):
    # Функция сдвига битов на одну позицию влево
    return x[1:] + x[:1]


def brent():
    # Открываем файл для чтения ключа
    input = open('keyScram.txt', 'r')
    x0 = input.read()
    input.close()
    # Считываем содержимое файла в переменную x0 и закрываем файл

    # Инициализация переменных для алгоритма Брента
    # переменные tortoise и hare устанавливаются равными строке x0, которая содержит начальную последовательность битов.
    tortoise = x0
    hare = f(x0)
    power = lam = 1

    # Поиск цикла
    # В этом блоке кода проверяется, на каком шаге циклической последовательности заяц (hare) встречается с черепахой
    # (tortoise). Каждый раз, когда они двигаются, счетчик mu увеличивается на 1. Таким образом, mu будет содержать
    # длину цикла.
    while tortoise != hare:
        if power == lam:
            tortoise = hare
            power *= 2
            lam = 0
        hare = f(hare)
        lam += 1
    # Алгоритм Флойда (черепаха и заяц)

    # Определение длины цикла
    mu = 0
    # переменные tortoise и hare устанавливаются в начальную последовательность битов x0.
    # Обе переменные начинают с этой точки.
    tortoise = hare = x0
    # В этом цикле заяц (переменная hare) продвигается вперед на lam шагов.
    # lam - это длина цикла, которая была найдена в предыдущем цикле.
    for i in range(lam):
        hare = f(hare)
    # В этом блоке кода заяц (hare) и черепаха (tortoise) двигаются по последовательности битов, пока они не встретятся
    # в одной и той же позиции. После этого переменная mu увеличивается на 1 с каждым шагом, пока заяц не догонит
    # черепаху. mu в итоге будет содержать длину цикла.
    while tortoise != hare:
        tortoise = f(tortoise)
        hare = f(hare)
        mu += 1

    # Вывод результата
    if mu == 0:
        print('Строка не является циклической.')
    else:
        print(f'Строка является циклической. Длина цикла: {lam}, сдвиг: {mu}.')

    return lam, mu
